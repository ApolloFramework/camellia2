//
// Â© 2016 UChicago Argonne.  For licensing details, see LICENSE-Camellia in the licenses directory.
//
//
//  CellTopologyTests.cpp
//  Camellia
//
//  Created by Nate Roberts on 12/11/14.
//
//

#include "Teuchos_UnitTestHarness.hpp"
#include "Teuchos_UnitTestHelpers.hpp"

#include "Intrepid_FieldContainer.hpp"

#include "CellTopology.h"

#include "CamelliaDebugUtility.h"

using namespace Intrepid;
using namespace Camellia;

namespace
{
// helper methods for some tests:
bool checkDimension(CellTopoPtr cellTopo)
{
  return cellTopo->getDimension() == cellTopo->getShardsTopology().getDimension() + cellTopo->getTensorialDegree();
}

bool checkPermutationCount(CellTopoPtr cellTopo)
{
  unsigned actualPermutationCount = cellTopo->getNodePermutationCount();
  unsigned expectedPermutationCount;
  if (cellTopo->isHypercube())
  {
    expectedPermutationCount = 1;
    for (int d=0; d<cellTopo->getDimension(); d++)
    {
      expectedPermutationCount *= 2 * (d+1);
    }
  }
  else
  {
    int shardsPermutationCount = cellTopo->getShardsTopology().getNodePermutationCount();
    expectedPermutationCount = shardsPermutationCount;
    if (cellTopo->getTensorialDegree() == 1)  expectedPermutationCount *= 2;
    else if (cellTopo->getTensorialDegree() > 1)
    {
      cout << "Test failure: unsupported tensorial degree.\n";
      return false;
    }
  }
  if (expectedPermutationCount != actualPermutationCount)
  {
    cout << "FAILURE: expected permutation count " << expectedPermutationCount << " did not match actual " << actualPermutationCount << endl;
  }
  else
  {
    //    cout << "actual permutation count matches expected: " << actualPermutationCount << endl;
  }
  return (expectedPermutationCount == actualPermutationCount);
}

bool checkPermutations(CellTopoPtr cellTopo)
{
  bool success = true;
  map< vector<unsigned>, unsigned > knownPermutations; // from permutation to its ordinal
  // true if all permutations are distinct and inverses do in fact invert
  int permutationCount = cellTopo->getNodePermutationCount();
  int nodeCount = cellTopo->getNodeCount();
  for (unsigned permutationNumber = 0; permutationNumber < permutationCount; permutationNumber++)
  {
    vector<unsigned> permutedNodes(nodeCount);
    set<unsigned> permutedNodeSet;
    for (unsigned node=0; node<nodeCount; node++)
    {
      unsigned permutedNode = cellTopo->getNodePermutation(permutationNumber, node);
      permutedNodes[node] = permutedNode;
      unsigned inversePermutedNode = cellTopo->getNodePermutationInverse(permutationNumber, permutedNode);
      permutedNodeSet.insert(permutedNode);
      if (inversePermutedNode != node)
      {
        success = false;
        cout << "Test failure: permutation number " << permutationNumber << " maps " << node << " to " << permutedNode;
        cout << ", but its inverse maps " << permutedNode << " to " << inversePermutedNode << endl;
      }
    }
    if (permutedNodeSet.size() < permutedNodes.size())
    {
      cout << "Test failure: permutation number " << permutationNumber << " has duplicate entries.\n";
      Camellia::print("permutedNodes", permutedNodes );
    }
    if (knownPermutations.find(permutedNodes) != knownPermutations.end())
    {
      cout << "Test failure: permutation number " << permutationNumber << " matched a node ordering previously ";
      cout << "generated by permutation number " << knownPermutations[permutedNodes] << endl;
      vector< vector<unsigned> > permList(permutationCount);
      for (map< vector<unsigned>, unsigned >::iterator knownPermIt = knownPermutations.begin(); knownPermIt != knownPermutations.end(); knownPermIt++)
      {
        permList[knownPermIt->second] = knownPermIt->first;
      }
      for (int i=0; i<permList.size(); i++)
      {
        ostringstream permNum;
        permNum << "permutation " << i;
        Camellia::print(permNum.str(), permList[i]);
      }

      success = false;
    }
    knownPermutations[permutedNodes] = permutationNumber;
  }

  return success;
}

vector< CellTopoPtr > getShardsTopologies()
{
  vector< CellTopoPtr > shardsTopologies;

  shardsTopologies.push_back(CellTopology::point());
  shardsTopologies.push_back(CellTopology::line());
  shardsTopologies.push_back(CellTopology::quad());
  shardsTopologies.push_back(CellTopology::triangle());
  shardsTopologies.push_back(CellTopology::hexahedron());
  //  shardsTopologies.push_back(CellTopology::tetrahedron()); // tetrahedron not yet supported by permutation
  return shardsTopologies;
}

TEUCHOS_UNIT_TEST( CellTopology, InitializeNodesLine)
{
  FieldContainer<double> lineNodes_x(2,1);

  lineNodes_x(0,0) =  0;
  lineNodes_x(1,0) =  1;

  vector< FieldContainer<double> > tensorComponentNodes(1);
  tensorComponentNodes[0] = lineNodes_x;

  FieldContainer<double> expectedNodes(2,1);
  // expect to get all the x0's then all the x1's, etc.
  expectedNodes(0,0) = lineNodes_x(0,0);
  expectedNodes(1,0) = lineNodes_x(1,0);

  FieldContainer<double> actualNodes(2,1);

  shards::CellTopology shardsLine(shards::getCellTopologyData<shards::Line<2> >() );

  int tensorialDegree = 0; // line + 0 for 1D
  CellTopoPtr lineTopo = CellTopology::cellTopology(shardsLine, tensorialDegree);

  lineTopo->initializeNodes(tensorComponentNodes, actualNodes);

  TEST_COMPARE_FLOATING_ARRAYS(expectedNodes, actualNodes, 1e-15);
}

TEUCHOS_UNIT_TEST( CellTopology, GetNodeFromTensorialComponentNodes)
{
  // just one concrete examples from the comments in the method to ensure it's doing what it claims

  /*
   Example: we have a base topology of 4 nodes x line x line.  Read addresses from right to left.

   address (1,0,0) --> 0 * (2 * 4) + 0 * 4 + 1 =  1
   address (0,1,0) --> 0 * (2 * 4) + 1 * 4 + 0 =  4
   address (0,0,1) --> 1 * (2 * 4) + 0 * 4 + 0 =  8
   address (0,1,1) --> 1 * (2 * 4) + 1 * 4 + 0 = 12

   */
  CellTopoPtr quad = CellTopology::quad();
  CellTopoPtr tensorTopo = CellTopology::cellTopology(quad->getShardsTopology(), 2);

  map< vector<unsigned>, unsigned > expectedTensorNodes;
  vector<unsigned> compNodes(3,0);
  compNodes[0] = 1;
  expectedTensorNodes[compNodes] = 1;
  compNodes[0] = 0;
  compNodes[1] = 1;
  compNodes[2] = 0;
  expectedTensorNodes[compNodes] = 4;
  compNodes[0] = 0;
  compNodes[1] = 0;
  compNodes[2] = 1;
  expectedTensorNodes[compNodes] = 8;
  compNodes[0] = 0;
  compNodes[1] = 1;
  compNodes[2] = 1;
  expectedTensorNodes[compNodes] = 12;

  for (map< vector<unsigned>, unsigned >::iterator entryIt = expectedTensorNodes.begin(); entryIt != expectedTensorNodes.end(); entryIt++)
  {
    unsigned tensorNode = tensorTopo->getNodeFromTensorialComponentNodes(entryIt->first);
    TEST_EQUALITY(entryIt->second, tensorNode);
  }
}

TEUCHOS_UNIT_TEST( CellTopology, InitializeNodesQuad)
{
  FieldContainer<double> lineNodes_x(2,1);
  FieldContainer<double> lineNodes_y(2,1);

  lineNodes_x(0,0) =  0;
  lineNodes_x(1,0) =  1;
  lineNodes_y(0,0) =  2;
  lineNodes_y(1,0) =  4;

  vector< FieldContainer<double> > tensorComponentNodes(2);
  tensorComponentNodes[0] = lineNodes_x;
  tensorComponentNodes[1] = lineNodes_y;

  FieldContainer<double> expectedNodes(4,2);
  // expect to see a copy of lineNodes_x with y0 as last dimension, then another copy with y1
  expectedNodes(0,0) = lineNodes_x(0,0);
  expectedNodes(0,1) = lineNodes_y(0,0);

  expectedNodes(1,0) = lineNodes_x(1,0);
  expectedNodes(1,1) = lineNodes_y(0,0);

  expectedNodes(2,0) = lineNodes_x(0,0);
  expectedNodes(2,1) = lineNodes_y(1,0);

  expectedNodes(3,0) = lineNodes_x(1,0);
  expectedNodes(3,1) = lineNodes_y(1,0);

  FieldContainer<double> actualNodes(4,2);
  actualNodes.initialize(-17); // to make clear what, if anything, is not being set

  shards::CellTopology shardsLine(shards::getCellTopologyData<shards::Line<2> >() );

  int tensorialDegree = 1; // line + 1 for 2D
  CellTopoPtr quadTopo = CellTopology::cellTopology(shardsLine, tensorialDegree);

  quadTopo->initializeNodes(tensorComponentNodes, actualNodes);

  TEST_COMPARE_FLOATING_ARRAYS(expectedNodes, actualNodes, 1e-15);
}

TEUCHOS_UNIT_TEST( CellTopology, InitializeNodesHexahedron)
{
  FieldContainer<double> lineNodes_x(2,1);
  FieldContainer<double> lineNodes_y(2,1);
  FieldContainer<double> lineNodes_z(2,1);

  lineNodes_x(0,0) =  0;
  lineNodes_x(1,0) =  1;
  lineNodes_y(0,0) =  2;
  lineNodes_y(1,0) =  4;
  lineNodes_z(0,0) = -3;
  lineNodes_z(1,0) =  3;

  vector< FieldContainer<double> > tensorComponentNodes(3);
  tensorComponentNodes[0] = lineNodes_x;
  tensorComponentNodes[1] = lineNodes_y;
  tensorComponentNodes[2] = lineNodes_z;

  FieldContainer<double> expectedNodes(8,3);
  expectedNodes(0,0) = lineNodes_x(0,0);
  expectedNodes(0,1) = lineNodes_y(0,0);
  expectedNodes(0,2) = lineNodes_z(0,0);

  expectedNodes(1,0) = lineNodes_x(1,0);
  expectedNodes(1,1) = lineNodes_y(0,0);
  expectedNodes(1,2) = lineNodes_z(0,0);

  expectedNodes(2,0) = lineNodes_x(0,0);
  expectedNodes(2,1) = lineNodes_y(1,0);
  expectedNodes(2,2) = lineNodes_z(0,0);

  expectedNodes(3,0) = lineNodes_x(1,0);
  expectedNodes(3,1) = lineNodes_y(1,0);
  expectedNodes(3,2) = lineNodes_z(0,0);


  expectedNodes(4,0) = lineNodes_x(0,0);
  expectedNodes(4,1) = lineNodes_y(0,0);
  expectedNodes(4,2) = lineNodes_z(1,0);

  expectedNodes(5,0) = lineNodes_x(1,0);
  expectedNodes(5,1) = lineNodes_y(0,0);
  expectedNodes(5,2) = lineNodes_z(1,0);

  expectedNodes(6,0) = lineNodes_x(0,0);
  expectedNodes(6,1) = lineNodes_y(1,0);
  expectedNodes(6,2) = lineNodes_z(1,0);

  expectedNodes(7,0) = lineNodes_x(1,0);
  expectedNodes(7,1) = lineNodes_y(1,0);
  expectedNodes(7,2) = lineNodes_z(1,0);

  FieldContainer<double> actualNodes(8,3);
  actualNodes.initialize(-17); // to make clear what, if anything, is not being set

  shards::CellTopology shardsLine(shards::getCellTopologyData<shards::Line<2> >() );

  int tensorialDegree = 2; // line + 2 for 3D
  CellTopoPtr hexTopo = CellTopology::cellTopology(shardsLine, tensorialDegree);

  hexTopo->initializeNodes(tensorComponentNodes, actualNodes);

  TEST_COMPARE_FLOATING_ARRAYS(expectedNodes, actualNodes, 1e-15);
}

TEUCHOS_UNIT_TEST( CellTopology, ShardsTopologiesPermutations )
{
  vector<CellTopoPtr> shardsTopologies = getShardsTopologies();
  for (int topoOrdinal=0; topoOrdinal < shardsTopologies.size(); topoOrdinal++)
  {
    CellTopoPtr cellTopo = shardsTopologies[topoOrdinal];
    TEST_ASSERT(checkPermutationCount(cellTopo));
    TEST_ASSERT(checkPermutations(cellTopo));
  }
}

TEUCHOS_UNIT_TEST( CellTopology, OneTensorTopologiesPermutations )
{
  // one tensorial dimension
  int tensorialDegree = 1;
  vector<CellTopoPtr> shardsTopologies = getShardsTopologies();
  for (int topoOrdinal=0; topoOrdinal < shardsTopologies.size(); topoOrdinal++)
  {
    shards::CellTopology shardsTopo = shardsTopologies[topoOrdinal]->getShardsTopology();
    CellTopoPtr cellTopo = CellTopology::cellTopology(shardsTopo, tensorialDegree);
    TEST_ASSERT(checkDimension(cellTopo));
    TEST_ASSERT(checkPermutationCount(cellTopo));
    TEST_ASSERT(checkPermutations(cellTopo));
  }
}

TEUCHOS_UNIT_TEST( CellTopology, SpaceTimeGetSideDimension )
{
  vector<CellTopoPtr> shardsTopologies = getShardsTopologies();
  for (int topoOrdinal=0; topoOrdinal < shardsTopologies.size(); topoOrdinal++)
  {
    CellTopoPtr shardsTopo = shardsTopologies[topoOrdinal];
    unsigned tensorialDegree = 1;
    CellTopoPtr spaceTimeTopo = CellTopology::cellTopology(shardsTopo->getShardsTopology(), tensorialDegree);

//      cout << "\nspaceTimeTopo: " << spaceTimeTopo->getName() << endl;

    out << "checking side dimension for " << spaceTimeTopo->getName() << endl;

    int sideCount = spaceTimeTopo->getSideCount();
    TEST_EQUALITY(sideCount, shardsTopo->getSideCount() + 2);

    int sideDim = spaceTimeTopo->getDimension() - 1;
    for (int sideOrdinal=0; sideOrdinal<sideCount; sideOrdinal++)
    {
      CellTopoPtr sideTopo = spaceTimeTopo->getSubcell(sideDim, sideOrdinal);
//        cout << "sideTopo: " << sideTopo->getName() << endl;
      TEST_EQUALITY(sideTopo->getDimension(), sideDim);
    }
  }
}

TEUCHOS_UNIT_TEST( CellTopology, SpaceTimeSideNumbering )
{
  vector<CellTopoPtr> shardsTopologies = getShardsTopologies();
  for (int topoOrdinal=0; topoOrdinal < shardsTopologies.size(); topoOrdinal++)
  {
    CellTopoPtr shardsTopo = shardsTopologies[topoOrdinal];
    unsigned tensorialDegree = 1;
    CellTopoPtr spaceTimeTopo = CellTopology::cellTopology(shardsTopo->getShardsTopology(), tensorialDegree);

    out << "checking side numbering for " << spaceTimeTopo->getName() << endl;

    int sideCount = spaceTimeTopo->getSideCount();
    TEST_EQUALITY(sideCount, shardsTopo->getSideCount() + 2);

    int sideDim = spaceTimeTopo->getDimension() - 1;
    for (int sideOrdinal=0; sideOrdinal<sideCount; sideOrdinal++)
    {
      if (spaceTimeTopo->sideIsSpatial(sideOrdinal))
      {
        // then this is a temporally extruded version of the spatial topology's side
        // check node count: should be double that of the spatial side
        int shardsSideOrdinal = spaceTimeTopo->getSpatialComponentSideOrdinal(sideOrdinal);
        int shardsSideNodeCount = shardsTopo->getNodeCount(sideDim-1, shardsSideOrdinal);
        int expectedSideNodeCount = 2 * shardsSideNodeCount;

        int sideNodeCount = spaceTimeTopo->getNodeCount(sideDim, sideOrdinal);
        TEST_EQUALITY(sideNodeCount, expectedSideNodeCount);

        for (int sideNode=0; sideNode<sideNodeCount; sideNode++)
        {
          int shardsSideNode = sideNode % shardsSideNodeCount;
          int shardsParentNode;
          if (sideDim >= 1)
            shardsParentNode = shardsTopo->getNodeMap(sideDim-1, shardsSideOrdinal, shardsSideNode);
          else
            shardsParentNode = 0;
          int expectedParentNode;
          if (sideNode < shardsSideNodeCount)
          {
            expectedParentNode = shardsParentNode;
          }
          else
          {
            expectedParentNode = shardsParentNode + shardsTopo->getNodeCount();
          }
          int parentNode = spaceTimeTopo->getNodeMap(sideDim, sideOrdinal, sideNode);
          TEST_EQUALITY(parentNode, expectedParentNode);
        }
      }
      else
      {
        unsigned temporalSideOrdinal = spaceTimeTopo->getTemporalComponentSideOrdinal(sideOrdinal);
        bool bottomSide = (temporalSideOrdinal == 0);

        int shardsNodeCount = shardsTopo->getNodeCount();
        int nodeOffset = bottomSide ? 0 : shardsNodeCount;

        int sideNodeCount = spaceTimeTopo->getNodeCount(sideDim, sideOrdinal);
        TEST_EQUALITY(sideNodeCount, shardsNodeCount);

        for (int shardsNode=0; shardsNode < shardsNodeCount; shardsNode++)
        {
          int expectedParentNode = shardsNode + nodeOffset;
          int parentNode = spaceTimeTopo->getNodeMap(sideDim, sideOrdinal, shardsNode);
          TEST_EQUALITY(expectedParentNode, parentNode);
        }

      }
    }
  }
}

//  TEUCHOS_UNIT_TEST( CellTopology, SpaceTimeSideNumbering_Line_2_x_Line_2 )
//  {
//    // in this test, we look at a particular space-time topology and check that sides are numbered as we expect
//    CellTopoPtr line = CellTopology::line();
//    int tensorialDegree = 1;
//    CellTopoPtr line_line = CellTopology::cellTopology(line->getShardsTopology(), tensorialDegree);
//
//    // nodes for temporally "bottom" side are 0 and 1
//    // nodes for top side are 2 and 3
//
//    // spatial sides (temporally extruded) are numbered 0 and 1
//    // side 0 has vertices 0 --> 2
//    // side 1 has vertices 1 --> 3
//
//    // temporal sides (copies of the spatial topology with constant time coordinate) are numbered 2 and 3
//    // side 2 has vertices 0 --> 1
//    // side 3 has vertices 2 --> 3
//
//    vector< pair<int,int> > sides(4);
//    sides[0] = make_pair(0, 2);
//    sides[1] = make_pair(1, 3);
//    sides[2] = make_pair(0, 1);
//    sides[3] = make_pair(2, 3);
//
//    // check that spatial sides are spatial
//    TEST_ASSERT( line_line->sideIsSpatial(0) );
//    TEST_ASSERT( line_line->sideIsSpatial(1) );
//
//    // check that temporal sides are not spatial:
//    TEST_ASSERT( ! line_line->sideIsSpatial(2) );
//    TEST_ASSERT( ! line_line->sideIsSpatial(3) );
//
//    int sideDim = line_line->getDimension() - 1;
//    for (int sideOrdinal=0; sideOrdinal<sides.size(); sideOrdinal++) {
//      int nodeCount = line_line->getNodeCount(sideDim, sideOrdinal);
//      TEST_EQUALITY(nodeCount, 2);
//      for (int scNode=0; scNode<nodeCount; scNode++) {
//        int parentNode = line_line->getNodeMap(sideDim, sideOrdinal, scNode);
//        if (scNode==0) TEST_EQUALITY(parentNode, sides[sideOrdinal].first);
//        if (scNode==1) TEST_EQUALITY(parentNode, sides[sideOrdinal].second);
//      }
//    }
//  }

TEUCHOS_UNIT_TEST( CellTopology, MultiTensorTopologiesPermutations )
{
  int minDimension = 1;
  int maxDimension = 4; // tested up to 6, but 4 is all we really are interested in...

  vector< CellTopoPtr > shardsHyperCubeTopos;
  shardsHyperCubeTopos.push_back(CellTopology::point());
  shardsHyperCubeTopos.push_back(CellTopology::line());
  shardsHyperCubeTopos.push_back(CellTopology::quad());
  shardsHyperCubeTopos.push_back(CellTopology::hexahedron());

  for (int shardsOrdinal=0; shardsOrdinal<shardsHyperCubeTopos.size(); shardsOrdinal++)
  {
    shards::CellTopology shardsTopo = shardsHyperCubeTopos[shardsOrdinal]->getShardsTopology();

    int minTensorialDegree = (minDimension > shardsTopo.getDimension()) ? minDimension - shardsTopo.getDimension() : 0;
    int maxTensorialDegree = (minDimension > shardsTopo.getDimension()) ? maxDimension - shardsTopo.getDimension() : 0;

    for (int tensorialDegree=minTensorialDegree; tensorialDegree <= maxTensorialDegree; tensorialDegree++)
    {
      CellTopoPtr cellTopo = CellTopology::cellTopology(shardsTopo, tensorialDegree);

      TEST_ASSERT(checkDimension(cellTopo));
      TEST_ASSERT(checkPermutationCount(cellTopo));
      TEST_ASSERT(checkPermutations(cellTopo));
    }
  }
}
} // namespace
